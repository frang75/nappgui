# CMake build functions script
# This file is part of NAppGUI-SDK project
# See README.txt and LICENSE.txt

#------------------------------------------------------------------------------

function(getSubDirectories dir _ret)
    set(dirList "")

    file(GLOB children RELATIVE ${dir} ${dir}/[a-zA-z_]*)

    foreach(child ${children})
        if(IS_DIRECTORY ${dir}/${child})
            list(APPEND dirList ${child})
        endif()
    endforeach()

    set(${_ret} ${dirList} PARENT_SCOPE)
endfunction()

#------------------------------------------------------------------------------

function(resourceGlobPatterns dir _ret)
    set(list_res "")

    foreach (item ${RES_EXTENSION})
        list(APPEND list_res ${dir}/${item})
    endforeach()

    set(${_ret} ${list_res} PARENT_SCOPE)
endfunction()

#------------------------------------------------------------------------------

function(isSourceSubDir subDirName _ret)

    string(TOLOWER ${subDirName} subDirLower)
    if (${subDirLower} STREQUAL win)
	    if (WIN32)
            set(${_ret} TRUE PARENT_SCOPE)
        else()
            set(${_ret} FALSE PARENT_SCOPE)
        endif()
    elseif (${subDirLower} STREQUAL unix) 
	    if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin"
            OR ${CMAKE_SYSTEM_NAME} MATCHES "Linux")
            set(${_ret} TRUE PARENT_SCOPE)
        else()
            set(${_ret} FALSE PARENT_SCOPE)
        endif()
    elseif (${subDirLower} STREQUAL osx)
	    if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
            set(${_ret} TRUE PARENT_SCOPE)
        else()
            set(${_ret} FALSE PARENT_SCOPE)
        endif()
    elseif (${subDirLower} STREQUAL linux)
        if (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
            set(${_ret} TRUE PARENT_SCOPE)
        else()
            set(${_ret} FALSE PARENT_SCOPE)
        endif()
    elseif (${subDirLower} STREQUAL gtk3)
        if (${CMAKE_TOOLKIT} MATCHES "GTK3")
	        set(${_ret} TRUE PARENT_SCOPE)
        else()
            set(${_ret} FALSE PARENT_SCOPE)
        endif()
    elseif (${subDirLower} STREQUAL res)
        set(${_ret} FALSE PARENT_SCOPE)
    else ()
        set(${_ret} TRUE PARENT_SCOPE)
    endif ()

endfunction()

#------------------------------------------------------------------------------

function(appendSrcFile targetName file)

    if ("${${targetName}_SRCFILES}" STREQUAL "")
        set(${targetName}_SRCFILES "${file}" CACHE INTERNAL "")
    else()
        list (FIND ${targetName}_SRCFILES ${file} index)
        if (${index} EQUAL -1)
            set(${targetName}_SRCFILES "${${targetName}_SRCFILES};${file}" CACHE INTERNAL "")
        else()
            message(FATAL_ERROR "Duplicated source file '${file}'")
        endif()
    endif()

endfunction()

#------------------------------------------------------------------------------

function(appendSrcSubDir targetName subDir)

    if ("${${targetName}_SRCSUBDIRS}" STREQUAL "")
        set(${targetName}_SRCSUBDIRS "${subDir}" CACHE INTERNAL "")
    else()
        list (FIND ${targetName}_SRCSUBDIRS ${subDir} index)
        if (${index} EQUAL -1)
            set(${targetName}_SRCSUBDIRS "${${targetName}_SRCSUBDIRS};${subDir}" CACHE INTERNAL "")
        endif ()
    endif()

endfunction()

#------------------------------------------------------------------------------

function(getRecursiveSourceFiles targetName dir group)

    file(GLOB children RELATIVE ${dir} ${dir}/[a-zA-z_]*)

    foreach(child ${children})
        if (IS_DIRECTORY ${dir}/${child})
            isSourceSubDir(${child} isSource)
            if (${isSource}) 
                getRecursiveSourceFiles(${targetName} "${dir}/${child}" "${group}/${child}")
            endif()
        else()
            get_filename_component(ext ${child} EXT)
            string(TOLOWER ${ext} extLower)
            list (FIND SRC_EXTENSION "*${extLower}" index)
            if (${index} GREATER -1)
                string(REPLACE "/" "\\" groupname ${group})
                source_group(${groupname} FILES ${dir}/${child})

                # Force header files 'Build errors with CMake >= 3.21.2'
                # https://gitlab.kitware.com/cmake/cmake/-/merge_requests/5926
                list (FIND HEADER_EXTENSION "*${extLower}" index)
                if (${index} GREATER -1)
                    set_source_files_properties(${dir}/${child} PROPERTIES HEADER_FILE_ONLY ON)
                    if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
                        set_source_files_properties(${dir}/${child} PROPERTIES XCODE_EXPLICIT_FILE_TYPE sourcecode.c.h)
                    endif()
                endif()

                appendSrcSubDir(${targetName} ${dir})
                appendSrcFile(${targetName} ${dir}/${child})
            endif()

        endif()

    endforeach()

endfunction()

#------------------------------------------------------------------------------

function(getResourceFiles targetName targetType dir _ret _include_dir)
    # All resource files in package
    set(res_files "")
    set(resPath ${dir}/res)

    if (EXISTS ${resPath})
		# Process Win32 .rc files 
		if (targetType MATCHES WIN_EXE)
			# VS2005 does not support .ico with 256 res
			if(MSVC_VERSION EQUAL 1400 OR MSVC_VERSION LESS 1400)
                file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/res.rc "APPLICATION_ICON ICON \"res\\\\logo48.ico\"\n")
                set(globalRes ${CMAKE_CURRENT_BINARY_DIR}/res.rc ${resPath}/logo48.ico)
			else()
                file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/res.rc "APPLICATION_ICON ICON \"res\\\\logo256.ico\"\n")
                set(globalRes ${CMAKE_CURRENT_BINARY_DIR}/res.rc ${resPath}/logo256.ico)
			endif()
		endif()

        if (EXISTS ${resPath}/license.txt)
            list(APPEND globalRes ${resPath}/license.txt)
        endif()

        if (EXISTS ${resPath}/pack.txt)
            list(APPEND globalRes ${resPath}/pack.txt)
        endif()

        source_group(res FILES ${globalRes})
        list(APPEND res_files ${globalRes})

    endif()

    # Target Resources
    set(nrc_mode ${TARGET_NRC_MODE_${targetName}})
    if (NOT ${nrc_mode} STREQUAL "NRC_NONE")
        getSubDirectories(${resPath} resPackDirs)

        # Clean the resource destiny directory
        set(DEST_RESDIR ${CMAKE_CURRENT_BINARY_DIR}/resgen)
        set(CMAKE_OUTPUT ${DEST_RESDIR}/NRCLog.txt)
        file(REMOVE_RECURSE ${DEST_RESDIR})
        file(MAKE_DIRECTORY ${DEST_RESDIR})

	    foreach(resPack ${resPackDirs})
            # Add resources to IDE
            set(resPackPath ${resPath}/${resPack})
            resourceGlobPatterns(${resPackPath} resGlob)
            file(GLOB resPackPathFiles ${resGlob})
            source_group("res\\${resPack}" FILES ${resPackPathFiles})
            list(APPEND res_files ${resPackPathFiles})

            # Add localized resources to IDE
            getSubDirectories(${resPath}/${resPack} resLocalDirs)
            foreach(resLocalDir ${resLocalDirs})
                set(resLocalPath ${resPath}/${resPack}/${resLocalDir})
                resourceGlobPatterns(${resLocalPath} resLocalGlob)
                file(GLOB resLocalPathFiles ${resLocalGlob})
                source_group("res\\${resPack}\\${resLocalDir}" FILES ${resLocalPathFiles})
                list(APPEND res_files ${resLocalPathFiles})
            endforeach()

            if (${nrc_mode} STREQUAL "NRC_EMBEDDED")
                set(NRC_OPTION "-dc")
            # '*.res' package will be copied in executable location
            elseif (${nrc_mode} STREQUAL "NRC_PACKED")
                set(NRC_OPTION "-dp")
            else()
                message (FATAL_ERROR "Unknown nrc mode")
            endif()

			file(TO_NATIVE_PATH \"${CMAKE_NRC}\" CMAKE_NRC)
			file(TO_NATIVE_PATH ${resPackPath} RESPACK_NATIVE)
			file(TO_NATIVE_PATH ${DEST_RESDIR}/${resPack}.c RESDEST_NATIVE)			
            execute_process(COMMAND "${CMAKE_NRC}" "${NRC_OPTION}" "${RESPACK_NATIVE}" "${RESDEST_NATIVE}" RESULT_VARIABLE nrcRes OUTPUT_VARIABLE nrcOut ERROR_VARIABLE nrcErr)
            file(APPEND ${CMAKE_OUTPUT} ${nrcOut})
            file(APPEND ${CMAKE_OUTPUT} ${nrcErr})
            if (NOT ${nrcRes} EQUAL "0")
                if (${nrcRes} EQUAL "1")
                    message("- nrc '${resPack}' warnings (See ${CMAKE_OUTPUT})")
                else()
                    message("- nrc '${resPack}' errors (${nrcRes}) (See ${CMAKE_OUTPUT})")
                    message("- ${nrcOut}")
                    message("- ${nrcErr}")
                endif()
            endif()

            list(APPEND resCompiled ${DEST_RESDIR}/${resPack}.c)            
            list(APPEND resCompiled ${DEST_RESDIR}/${resPack}.h)
            source_group("res\\${resPack}\\gen" FILES ${resCompiled})                        
            list(APPEND res_files ${resCompiled})
            
            set(${_include_dir} ${DEST_RESDIR} PARENT_SCOPE)
             
	    endforeach()

    endif()

    set(${_ret} ${res_files} PARENT_SCOPE)

endfunction()

#------------------------------------------------------------------------------

function(installResourcePacks targetName targetType sourceDir)
    set (resourcePath ${sourceDir}/res)

    # Apple Bundle always have a resource dir
    if (targetType MATCHES APPLE_BUNDLE)
        set(resourceDestPath "../resources")
        add_custom_command(TARGET ${targetName} POST_BUILD COMMAND ${CMAKE_COMMAND} -E make_directory $<TARGET_FILE_DIR:${targetName}>/${resourceDestPath})
        add_custom_command(TARGET ${targetName} POST_BUILD COMMAND ${CMAKE_COMMAND} -E make_directory $<TARGET_FILE_DIR:${targetName}>/${resourceDestPath}/en.lproj)

        # Bundle icon
        if (EXISTS ${resourcePath}/logo.icns)
            add_custom_command(TARGET ${targetName} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy ${resourcePath}/logo.icns $<TARGET_FILE_DIR:${targetName}>/${resourceDestPath})
        else()
            message(WARNING "logo.icns doesn't exists in '${resourcePath}'")
        endif()

    # Linux needs the app icon near the executable
    elseif (targetType MATCHES LINUX_BUNDLE)

        if (EXISTS ${resourcePath}/logo48.ico)
            add_custom_command(TARGET ${targetName} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy ${resourcePath}/logo48.ico $<TARGET_FILE_DIR:${targetName}>/logo.ico)
        else()
            message(WARNING "logo48.ico doesn't exists in '${resourcePath}'")
        endif()

    endif()
    
    set(nrc_mode ${TARGET_NRC_MODE_${targetName}})
    if (${nrc_mode} STREQUAL "NRC_PACKED")
        set(resPath ${sourceDir}/res)
        set(DEST_RESDIR ${CMAKE_CURRENT_BINARY_DIR}/resgen)

        # Create 'res' directory for packed resources
        # In the same location as executable
	    if (WIN32)
            set(resRelative "res")
            add_custom_command(TARGET ${targetName} POST_BUILD COMMAND ${CMAKE_COMMAND} -E make_directory $<TARGET_FILE_DIR:${targetName}>/${resRelative})
        elseif (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
            # For macOS bundles, resource dir is created in 'macOSBundle'
            set(resRelative "../resources")
        elseif (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
            set(resRelative "res")
            add_custom_command(TARGET ${targetName} POST_BUILD COMMAND ${CMAKE_COMMAND} -E make_directory $<TARGET_FILE_DIR:${targetName}>/${resRelative})
	    else()
	       message(FATAL_ERROR "Unknown system")
        endif()
       
        getSubDirectories(${resPath} resPackDirs)

        # Copy all resource packs
	    foreach(resSubDir ${resPackDirs})
            add_custom_command(TARGET ${bundleName} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy ${DEST_RESDIR}/${resSubDir}.res $<TARGET_FILE_DIR:${targetName}>/${resRelative})
	    endforeach()

    endif()

endfunction()

#------------------------------------------------------------------------------

function(getDirectDepends path _ret)

    if (${path}_DIRECTDEPENDS)
        set(${_ret} ${${path}_DIRECTDEPENDS} PARENT_SCOPE)

	else()
        set(${_ret} "" PARENT_SCOPE)

    endif()

endfunction()

#------------------------------------------------------------------------------

function(appendIncludeDependency targetName depend)

    if ("${${targetName}_INCLUDEDEPENDS}" STREQUAL "")
        set(${targetName}_INCLUDEDEPENDS "${depend}" CACHE INTERNAL "")
    else()
        list (FIND ${targetName}_INCLUDEDEPENDS ${depend} index)
        if (${index} EQUAL -1)
            set(${targetName}_INCLUDEDEPENDS "${${targetName}_INCLUDEDEPENDS};${depend}" CACHE INTERNAL "")
        endif ()
    endif()

endfunction()

#------------------------------------------------------------------------------

function(getRecursiveTargetIncludes targetName dependList)

	foreach(depend ${dependList})

        get_filename_component(dependName ${depend} NAME)
		if (TARGET ${dependName})
            appendIncludeDependency(${targetName} ${CMAKE_SRC_PATH}/${depend})
            getDirectDepends(${depend} childDependList)

        elseif (EXISTS ${CMAKE_INC_PATH}/${depend})            
            appendIncludeDependency(${targetName} ${CMAKE_INC_PATH}/${depend})
            getDirectDepends(${depend} childDependList)

        else()
			# May exists binaries in 'lib' without include files
			set(childDependList "")

        endif()

        if (childDependList)
            getRecursiveTargetIncludes(${targetName} "${childDependList}")
        endif()

	endforeach()

endfunction()

#------------------------------------------------------------------------------

function(targetDependsIncludeDirectories targetName firstLevelDepends) 

    set(${targetName}_INCLUDEDEPENDS "" CACHE INTERNAL "")
    getRecursiveTargetIncludes(${targetName} "${firstLevelDepends}")

    if (NOT "${${targetName}_INCLUDEDEPENDS}" STREQUAL "")
        target_include_directories(${targetName} PUBLIC "${${targetName}_INCLUDEDEPENDS}")
    endif()

endfunction()

#------------------------------------------------------------------------------

function(processTarget targetName targetType dependList)
    message(STATUS "- ${targetName}: Starting")

    # Get Files
    set(${targetName}_SRCFILES "" CACHE INTERNAL "")
    set(${targetName}_SRCSUBDIRS "" CACHE INTERNAL "")
    getRecursiveSourceFiles(${targetName} ${CMAKE_CURRENT_SOURCE_DIR} "src")
    set(srcFiles ${${targetName}_SRCFILES})
    set(srcSubDirs ${${targetName}_SRCSUBDIRS})

    getResourceFiles(${targetName} ${targetType} ${CMAKE_CURRENT_SOURCE_DIR} resFiles resIncludeDir)
    
    # TARGET Build
    if (targetType MATCHES STATIC_LIB)
        add_library(${targetName} STATIC ${srcFiles} ${resFiles})
    elseif (targetType MATCHES WIN_EXE)
        add_executable(${targetName} WIN32 ${srcFiles} ${resFiles})
    elseif (targetType MATCHES WIN_CONSOLE)
        add_executable(${targetName} ${srcFiles} ${resFiles})
    elseif (targetType MATCHES WIN_DLL)
        add_library(${targetName} SHARED ${srcFiles} ${resFiles})
    elseif (targetType MATCHES APPLE_BUNDLE)
        add_executable(${targetName} MACOSX_BUNDLE ${srcFiles} ${resFiles})
    elseif (targetType MATCHES APPLE_CONSOLE)
        add_executable(${targetName} ${srcFiles} ${resFiles})
    elseif (targetType MATCHES LINUX_EXE)
        add_executable(${targetName} ${srcFiles} ${resFiles})
    elseif (targetType MATCHES LINUX_BUNDLE)
        add_executable(${targetName} ${srcFiles} ${resFiles})
    else()
        message(FATAL_ERROR "Unknown target type")
    endif()
    
    # IDE Properties for TARGET
    if (IDE_PROPERTIES)
        set_target_properties(${targetName} PROPERTIES ${IDE_PROPERTIES})
    endif()

    # Resource packs
    installResourcePacks(${targetName} ${targetType} ${CMAKE_CURRENT_SOURCE_DIR})

    # Target Definitions
	set_property(TARGET ${targetName} APPEND PROPERTY COMPILE_DEFINITIONS $<$<CONFIG:Debug>:CMAKE_DEBUG>)
    set_property(TARGET ${targetName} APPEND PROPERTY COMPILE_DEFINITIONS $<$<CONFIG:Release>:CMAKE_RELEASE>)
    set_property(TARGET ${targetName} APPEND PROPERTY COMPILE_DEFINITIONS $<$<CONFIG:ReleaseWithAssert>:CMAKE_RELEASEWITHASSERT>)
    
    if (WIN32)
        # Visual Studio 2005/2008 doesn't have <stdint.h>
        if(MSVC_VERSION EQUAL 1500 OR MSVC_VERSION LESS 1500)		
            target_include_directories(${targetName} PUBLIC ${CMAKE_PRJ_PATH}/depend)
        endif()

        # Platform toolset macro
        set_property(TARGET ${targetName} APPEND PROPERTY COMPILE_DEFINITIONS VS_PLATFORM=${VS_TOOLSET_NUMBER})        

        # Disable linker '4099' "pdb" warnings
        # Disable linker '4098' mixed (static/dynamic) runtime library warnings
        set_target_properties(${targetName} PROPERTIES LINK_FLAGS "/ignore:4099 /ignore:4098")

    endif()

    # GTK Include directories
    if (${CMAKE_TOOLKIT} MATCHES "GTK3")    
        if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/gtk3)
            # Use the package PkgConfig to detect GTK+ headers/library files
            find_package(PkgConfig REQUIRED)
            pkg_check_modules(GTK3 REQUIRED gtk+-3.0)        
            target_include_directories(${targetName} PUBLIC ${GTK3_INCLUDE_DIRS})
            set_target_properties(${targetName} PROPERTIES COMPILE_FLAGS "-D__GTK3_TOOLKIT__")            
        endif()
    endif()     

    # TARGET local directory include
    target_include_directories(${targetName} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

    # TARGET local subdirectories includes
    foreach (srcSubDir ${srcSubDirs})
        target_include_directories(${targetName} PUBLIC ${srcSubDir})
    endforeach()

    # Include dir for target generated resources
    if (resIncludeDir)
        target_include_directories(${targetName} PUBLIC ${resIncludeDir})
    endif()
    		
    if (dependList)
        foreach(dependency ${dependList})        
            get_filename_component(dependencyName ${dependency} NAME)                                        
            if (TARGET ${dependencyName})
                add_dependencies(${targetName} ${dependencyName})
            endif()
        endforeach()

        # Recursive directory includes 
        targetDependsIncludeDirectories(${targetName} "${dependList}")
    endif()

    message(STATUS "- ${targetName}: Completed ")
endfunction()

#------------------------------------------------------------------------------

function(processStaticLib libName dependList)
    processTarget("${libName}" "STATIC_LIB" "${dependList}")
    
    # In Linux, static libs must link with other libs 
    if (${CMAKE_SYSTEM_NAME} MATCHES "Linux")    
        targetLinkWithLibraries(${libName} "${dependencies}")
    endif()
        
endfunction()

#------------------------------------------------------------------------------

function(setDotNetProps targetName dotnetDependList dotnetFramework)
	set(DOTNET_LIBS System ${dotnetDependList})
	set_target_properties(${targetName} PROPERTIES VS_DOTNET_REFERENCES "${DOTNET_LIBS}")        

	# C++/Cli is not compatible with '/MT' runtime library
	target_compile_options(${targetName} PUBLIC "$<$<CONFIG:Debug>:/MDd>")
	target_compile_options(${targetName} PUBLIC "$<$<CONFIG:Release>:/MD>")
	target_compile_options(${targetName} PUBLIC "$<$<CONFIG:ReleaseWithAssert>:/MD>")

	# DOTNET Framework version
	set_target_properties(${targetName} PROPERTIES DOTNET_TARGET_FRAMEWORK_VERSION v${dotnetFramework})

endfunction()

#------------------------------------------------------------------------------

function(windowsBundle bundleName bundleType dependList)
    processTarget("${bundleName}" "${bundleType}" "${dependList}")
endfunction()

#------------------------------------------------------------------------------

function(bundleProp bundleName property value)
    # Fails in XCode 3.2, 4
    # /bin/bash -c "plutil -replace NSHumanReadableCopyright -string 2019\ NAppGUI .../Info.plist"
    # unrecognized option: -replace
    if(${XCODE_VERSION} VERSION_GREATER "5.99")
        add_custom_command(TARGET ${bundleName} POST_BUILD COMMAND /bin/bash -c \"plutil -replace ${property} -string "${value}" $<TARGET_FILE_DIR:${targetName}>/../Info.plist\")
    endif()
endfunction()

#------------------------------------------------------------------------------

function(macOSBundle bundleName dependList)

    processTarget("${bundleName}" APPLE_BUNDLE "${dependList}")

    # Info.plist configure
    # Proyect provides its own Info.plist?
    if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/Info.plist)
        set_target_properties(${bundleName} PROPERTIES MACOSX_BUNDLE_INFO_PLIST ${CMAKE_CURRENT_SOURCE_DIR}/Info.plist)
    # Use default template
    else()
        set_target_properties(${bundleName} PROPERTIES MACOSX_BUNDLE_INFO_PLIST ${CMAKE_PRJ_PATH}/templates/Info.plist)
    endif()

    # Overwrite some properties
    bundleProp(${bundleName} NSHumanReadableCopyright "${CURRENT_YEAR} ${PACK_VENDOR}")
    bundleProp(${bundleName} CFBundleVersion "${PACK_VERSION}")

    target_link_libraries(${bundleName} ${COCOA_LIB})

endfunction()

#------------------------------------------------------------------------------

function(linuxBundle bundleName dependList)
    processTarget("${bundleName}" LINUX_BUNDLE "${dependList}")
    file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE})    
    set_target_properties(${bundleName} PROPERTIES RUNTIME_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_BUILD_TYPE}")
endfunction()

#------------------------------------------------------------------------------

function(appendLinkDependency targetName depend)

    if ("${${targetName}_LINKDEPENDS}" STREQUAL "")
        set(${targetName}_LINKDEPENDS "${depend}" CACHE INTERNAL "")
    else()
        #list (FIND ${targetName}_LINKDEPENDS ${depend} index)
        #if (${index} EQUAL -1)
            set(${targetName}_LINKDEPENDS "${${targetName}_LINKDEPENDS};${depend}" CACHE INTERNAL "")
        #endif ()
    endif()

endfunction()

#------------------------------------------------------------------------------

function(appendBinaryLinkDependency targetName depend)

    if ("${${targetName}_LINKDEPENDS}" STREQUAL "")
        set(${targetName}_LINKDEPENDS "${depend}" CACHE INTERNAL "")
    # In Linux (GCC) we need the entire chain of binary dependencies (don't delete duplicates)
    elseif (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
        set(${targetName}_LINKDEPENDS "${${targetName}_LINKDEPENDS};${depend}" CACHE INTERNAL "")
    else()
        list (FIND ${targetName}_LINKDEPENDS ${depend} index)
        if (${index} EQUAL -1)        
            set(${targetName}_LINKDEPENDS "${${targetName}_LINKDEPENDS};${depend}" CACHE INTERNAL "")
        endif ()
    endif()

endfunction()

#------------------------------------------------------------------------------

function(binaryTarget targetName _ret)

    if (NOT NAPPGUI_COMPILER_TOOLSET)
        message(FATAL_ERROR "NAPPGUI_COMPILER_TOOLSET Not Set")
    endif()
			
    if (NOT NAPPGUI_ARCH)
        message(FATAL_ERROR "NAPPGUI_ARCH Not Set")
    endif()

    if (NOT NAPPGUI_LIB_PREFIX)
        set(NAPPGUI_LIB_PREFIX "")
    endif()

    if (NOT NAPPGUI_LIB_SUFFIX)
        message(FATAL_ERROR "NAPPGUI_LIB_SUFFIX Not Set")
    endif()

    set(BINARY_DIR ${CMAKE_LIB_PATH}/${NAPPGUI_COMPILER_TOOLSET}_${NAPPGUI_ARCH})
    if (EXISTS ${BINARY_DIR})
        if (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
            set(${_ret} ${BINARY_DIR}/${CMAKE_BUILD_CONFIG}/${NAPPGUI_LIB_PREFIX}${targetName}${NAPPGUI_LIB_SUFFIX} PARENT_SCOPE)
        else()
            set(${_ret} ${BINARY_DIR}/${CMAKE_CFG_INTDIR}/${NAPPGUI_LIB_PREFIX}${targetName}${NAPPGUI_LIB_SUFFIX} PARENT_SCOPE)
        endif()
    else()
        set(${_ret} "" PARENT_SCOPE)
    endif()

endfunction()

#------------------------------------------------------------------------------

function(getRecursiveTargetLinks targetName dependList)

	foreach(depend ${dependList})
        get_filename_component(dependName ${depend} NAME)

		# Dependency is a source project
		if (TARGET ${dependName})
            get_target_property(TARGET_TYPE ${dependName} TYPE)
            if (${TARGET_TYPE} STREQUAL "STATIC_LIBRARY")
                appendLinkDependency(${targetName} ${dependName})
                getDirectDepends(${depend} childDependList)
            endif ()

        else()		
			# Check if dependency is a binary
			get_filename_component(libDir ${depend} DIRECTORY)
			get_filename_component(libName ${depend} NAME)
			set(libBinaryPath ${CMAKE_LIB_PATH}/${NAPPGUI_COMPILER_TOOLSET}_${NAPPGUI_ARCH}/Debug/${libDir}/${NAPPGUI_LIB_PREFIX}${libName}${NAPPGUI_LIB_SUFFIX})
		
			if (EXISTS ${libBinaryPath})
				binaryTarget(${depend} binaryName)				
				appendBinaryLinkDependency(${targetName} ${binaryName})
				getDirectDepends(${depend} childDependList)
				                				
			else()
				message(FALTAL_ERROR "'${depend}' Unknown dependency")

			endif()

        endif()
        
        if (childDependList)
            getRecursiveTargetLinks(${targetName} "${childDependList}")
        endif()

	endforeach()

endfunction()

#------------------------------------------------------------------------------

function(existsDepend targetName depend _ret)
    list (FIND ${targetName}_LINKDEPENDS ${depend} _index)        
    if (${_index} GREATER -1)
        set(${_ret} ${_index} PARENT_SCOPE)
    else()
        binaryTarget(${depend} binaryName)
        if (NOT "${binaryName}" STREQUAL "")
            list (FIND ${targetName}_LINKDEPENDS ${binaryName} _index)        
            set(${_ret} ${_index} PARENT_SCOPE)
        else()
            set(${_ret} "-1" PARENT_SCOPE)            
        endif()
    endif()
endfunction()

#------------------------------------------------------------------------------

function(targetDependOnLib targetName libName _ret)

    set(${_ret} "NO" PARENT_SCOPE)

    if (${targetName} MATCHES "${libName}")
        set(${_ret} "YES" PARENT_SCOPE)
        return()
    endif()

    foreach(lib in ${${targetName}_LINKDEPENDS})

        if (${lib} MATCHES "${libName}")
            set(${_ret} "YES" PARENT_SCOPE)
            return()
        endif()

        if (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
                
            if (${lib} MATCHES ".*lib${libName}.a")
                set(${_ret} "YES" PARENT_SCOPE)
                return()
            endif()
        
        endif()
        
    endforeach()

endfunction()

#------------------------------------------------------------------------------

function(targetLinkWithLibraries targetName firstLevelDepends) 

    set(${targetName}_LINKDEPENDS "" CACHE INTERNAL "")
    getRecursiveTargetLinks(${targetName} "${firstLevelDepends}")
    
    if (NOT "${${targetName}_LINKDEPENDS}" STREQUAL "")    
        target_link_libraries(${targetName} ${${targetName}_LINKDEPENDS})
    endif()
           
    # Target should link with pthread
    if (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
        targetDependOnLib(${targetName} "osbs" _depends)    
        if (${_depends} STREQUAL "YES")
            target_link_libraries(${targetName} pthread)
        endif()
    endif()
                     
    # Target should link with GTK3
    if (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
        if (${CMAKE_TOOLKIT} MATCHES "GTK3")        
            targetDependOnLib(${targetName} "draw2d" _depends)
            if (${_depends} STREQUAL "YES")            
                # Use the package PkgConfig to detect GTK+ headers/library files
                find_package(PkgConfig REQUIRED)
                pkg_check_modules(GTK3 REQUIRED gtk+-3.0)
                target_link_libraries(${targetName} ${GTK3_LIBRARIES})            
            endif()                        
        endif()
    endif()

    # Target should link with libCurl
    if (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
        targetDependOnLib(${targetName} "inet" _depends)    
        if (${_depends} STREQUAL "YES")
            find_package(CURL)
            if (${CURL_FOUND})
                target_link_libraries(${targetName} ${CURL_LIBRARY})                
            else()            
                message(ERROR "- libCURL is required. Try 'sudo apt-get install libcurl4-openssl-dev'")                
            endif()        
        endif()                        
    endif()
        

endfunction()

#------------------------------------------------------------------------------

function(readPackFile)

    if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/res/pack.txt)
        file(STRINGS ${CMAKE_CURRENT_SOURCE_DIR}/res/pack.txt PackContents)
        foreach(NameAndValue ${PackContents})
            # Strip leading spaces
            string(REGEX REPLACE "^[ ]+" "" NameAndValue ${NameAndValue})
            # Find variable name
            string(REGEX MATCH "^[^=]+" Name ${NameAndValue})
            # Find the value
            string(REPLACE "${Name}=" "" Value ${NameAndValue})
            # Set the variable
            set(PACK_${Name} "${Value}" PARENT_SCOPE)
       endforeach()
    endif()

endfunction()

#------------------------------------------------------------------------------

function(installerScript targetName platform generator config)    
    set(SCRIPT ${CMAKE_CURRENT_BINARY_DIR}/CPack-${targetName}-${config}.cmake)
    file(WRITE ${SCRIPT} "# CPack script for ${targetName} project\n")
    file(APPEND ${SCRIPT} "# Automatic generated by NAppGUI\n")
    file(APPEND ${SCRIPT} "# You can configure the installer from /res/pack.txt\n")
    file(APPEND ${SCRIPT} "set(CPACK_GENERATOR \"${generator}\")\n")
    file(APPEND ${SCRIPT} "set(CPACK_INSTALLED_DIRECTORIES \"${CMAKE_CURRENT_BINARY_DIR}/${config};.\")\n")
    file(APPEND ${SCRIPT} "set(CPACK_SYSTEM_NAME \"${platform}_${NAPPGUI_ARCH}\")\n")
    file(APPEND ${SCRIPT} "set(CPACK_PACKAGE_NAME \"${targetName}\")\n")
    file(APPEND ${SCRIPT} "set(CPACK_PACKAGE_VENDOR \"${PACK_VENDOR}\")\n")
    file(APPEND ${SCRIPT} "set(CPACK_PACKAGE_VERSION \"${PACK_VERSION}\")\n")
    file(APPEND ${SCRIPT} "set(CPACK_PACKAGE_DESCRIPTION \"${PACK_DESC}\")\n")
    file(APPEND ${SCRIPT} "set(CPACK_PACKAGE_FILE_NAME \"\${CPACK_PACKAGE_NAME}\")\n")
    #file(APPEND ${SCRIPT} "set(CPACK_PACKAGE_FILE_NAME \"\${CPACK_PACKAGE_NAME}-\${CPACK_PACKAGE_VERSION}-\${CPACK_SYSTEM_NAME}\")\n")
    file(APPEND ${SCRIPT} "set(CPACK_PACKAGE_INSTALL_REGISTRY_KEY \"\${PACK_VENDOR}/\${CPACK_PACKAGE_NAME}-${NAPPGUI_ARCH}\")\n")

    if (${generator} MATCHES "NSIS")
 
 file(APPEND ${SCRIPT} "\n")
        file(APPEND ${SCRIPT} "# NSIS generator specific options\n")
        file(APPEND ${SCRIPT} "set(CPACK_NSIS_PACKAGE_NAME \"\${CPACK_PACKAGE_FILE_NAME}\")\n")
        file(APPEND ${SCRIPT} "set(CPACK_NSIS_DISPLAY_NAME \"\${CPACK_PACKAGE_NAME} (${NAPPGUI_ARCH})\")\n")
        file(APPEND ${SCRIPT} "set(CPACK_NSIS_MUI_ICON \"${CMAKE_CURRENT_SOURCE_DIR}/res\\\\logo256.ico\")\n")
        file(APPEND ${SCRIPT} "set(CPACK_NSIS_MUI_UNIICON \"${CMAKE_CURRENT_SOURCE_DIR}/res\\\\logo256.ico\")\n")
        file(APPEND ${SCRIPT} "set(CPACK_PACKAGE_ICON \"${CMAKE_CURRENT_SOURCE_DIR}/res\\\\banner.bmp\")\n")
        file(APPEND ${SCRIPT} "set(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_CURRENT_SOURCE_DIR}/res/license.txt\")\n")

        if (${NAPPGUI_ARCH} MATCHES "x64")
            file(APPEND ${SCRIPT} "set(CPACK_NSIS_INSTALL_ROOT \"\$PROGRAMFILES64\\\\\${CPACK_PACKAGE_VENDOR}\\\\\${CPACK_PACKAGE_NAME}\")\n")
        else()
            file(APPEND ${SCRIPT} "set(CPACK_NSIS_INSTALL_ROOT \"\$PROGRAMFILES\\\\\${CPACK_PACKAGE_VENDOR}\\\\\${CPACK_PACKAGE_NAME}\")\n")
        endif()

        file(APPEND ${SCRIPT} "set(CPACK_NSIS_INSTALLED_ICON_NAME \"\${CPACK_PACKAGE_NAME}.exe\")\n")
        file(APPEND ${SCRIPT} "set(CPACK_NSIS_MENU_LINKS \"\${CPACK_PACKAGE_NAME}.exe\" \"\${CPACK_PACKAGE_NAME} (${NAPPGUI_ARCH})\")\n")
        file(APPEND ${SCRIPT} "set(CPACK_NSIS_DEFINES \"!define MUI_STARTMENUPAGE_DEFAULTFOLDER \\\\\${CPACK_PACKAGE_VENDOR}\\\\\${CPACK_PACKAGE_NAME}\")\n")

    elseif (${generator} MATCHES "DragNDrop")
        file(APPEND ${SCRIPT} "set(CPACK_DMG_VOLUME_NAME \"\${CPACK_PACKAGE_NAME}\")\n")
        add_custom_command(TARGET ${targetName} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/res/license.txt ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIGURATION>)

    elseif (${generator} MATCHES "TGZ")
        add_custom_command(TARGET ${targetName} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/res/license.txt ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIGURATION>)
    endif()

endfunction()

#------------------------------------------------------------------------------

function(processInstaller targetName)
    if (CMAKE_PACKAGE_PATH)

        if (NOT EXISTS ${CMAKE_PACKAGE_PATH}/Debug)
            file(MAKE_DIRECTORY ${CMAKE_PACKAGE_PATH}/Debug)
        endif()
       
        if (NOT EXISTS ${CMAKE_PACKAGE_PATH}/Release)
            file(MAKE_DIRECTORY ${CMAKE_PACKAGE_PATH}/Release)
        endif()
        
        if (NOT EXISTS ${CMAKE_PACKAGE_PATH}/ReleaseWithAssert)
            file(MAKE_DIRECTORY ${CMAKE_PACKAGE_PATH}/ReleaseWithAssert)
        endif()

	    if (WIN32)
            installerScript(${targetName} "win" ${CMAKE_PACKAGE_GEN} "Debug")
            installerScript(${targetName} "win" ${CMAKE_PACKAGE_GEN} "Release")
            installerScript(${targetName} "win" ${CMAKE_PACKAGE_GEN} "ReleaseWithAssert")
            add_custom_command(TARGET ${targetName} POST_BUILD COMMAND cd ${CMAKE_PACKAGE_PATH}/$<CONFIGURATION> & cpack --config ${CMAKE_CURRENT_BINARY_DIR}/CPack-${targetName}-$<CONFIGURATION>.cmake)

        elseif (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
            installerScript(${targetName} "macos" ${CMAKE_PACKAGE_GEN} "Debug")
            installerScript(${targetName} "macos" ${CMAKE_PACKAGE_GEN} "Release")
            installerScript(${targetName} "macos" ${CMAKE_PACKAGE_GEN} "ReleaseWithAssert")
            add_custom_command(TARGET ${targetName} POST_BUILD COMMAND /bin/bash -c \"cd ${CMAKE_PACKAGE_PATH}/$<CONFIGURATION> && ${CPACK_COMMAND} --config ${CMAKE_CURRENT_BINARY_DIR}/CPack-${targetName}-$<CONFIGURATION>.cmake\")

        else()
            installerScript(${targetName} "linux" ${CMAKE_PACKAGE_GEN} "Debug")
            installerScript(${targetName} "linux" ${CMAKE_PACKAGE_GEN} "Release")
            installerScript(${targetName} "linux" ${CMAKE_PACKAGE_GEN} "ReleaseWithAssert")
            add_custom_command(TARGET ${targetName} POST_BUILD COMMAND /bin/bash -c \"cd ${CMAKE_PACKAGE_PATH}/$<CONFIGURATION> && ${CPACK_COMMAND} --config ${CMAKE_CURRENT_BINARY_DIR}/CPack-${targetName}-$<CONFIGURATION>.cmake\")

        endif() 
    else()
        message("- ${targetName}: set CMAKE_PACKAGE_PATH to create packages")
    endif()
endfunction()

#------------------------------------------------------------------------------

function(processDesktopApp appName dependList)

    readPackFile()
    set(dependencies "osapp")
    list(APPEND dependencies "${dependList}")
	if (WIN32)
		windowsBundle(${appName} WIN_EXE "${dependencies}")
		set_target_properties(${appName} PROPERTIES LINK_FLAGS_DEBUG "/SUBSYSTEM:WINDOWS")
		set_target_properties(${appName} PROPERTIES LINK_FLAGS_RELASE "/SUBSYSTEM:WINDOWS")
		set_target_properties(${appName} PROPERTIES LINK_FLAGS_RELASEWITHASSERT "/SUBSYSTEM:WINDOWS")

    elseif (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
        macOSBundle(${appName} "${dependencies}")

    elseif (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
        linuxBundle(${appName} "${dependencies}")

    else()
        message("Unknown platform")

	endif()

    targetLinkWithLibraries(${appName} "${dependencies}") 

    if (${CMAKE_PACKAGE})
        processInstaller(${appName})
    endif()

endfunction()

#------------------------------------------------------------------------------

function(macOSCommand appName dependList)
    processTarget("${appName}" APPLE_CONSOLE "${dependList}")
    target_link_libraries(${appName} ${COCOA_LIB})
endfunction()

#------------------------------------------------------------------------------

function(linuxCommand appName dependList)
    processTarget("${appName}" LINUX_EXE "${dependList}")
endfunction()

#------------------------------------------------------------------------------

function(processCommandApp appName dependList)

    #set(dependencies "core")
    set(dependencies "")
    list(APPEND dependencies "${dependList}")

    if (WIN32)
        windowsBundle(${appName} WIN_CONSOLE "${dependencies}")
        set_target_properties(${appName} PROPERTIES LINK_FLAGS_DEBUG "/SUBSYSTEM:CONSOLE")
        set_target_properties(${appName} PROPERTIES LINK_FLAGS_RELASE "/SUBSYSTEM:CONSOLE")
        set_target_properties(${appName} PROPERTIES LINK_FLAGS_RELEASEWITHASSERT "/SUBSYSTEM:CONSOLE")

    elseif (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
        macOSCommand("${appName}" "${dependencies}")

    elseif (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
        linuxCommand("${appName}" "${dependencies}")

    else()
        message(ERROR "- ${appName} Unknown system")

    endif()

    targetLinkWithLibraries(${appName} "${dependencies}")

endfunction()

#------------------------------------------------------------------------------

function(addTarget targetName targetPath nrcMode)

    if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${targetPath})
        set(TARGET_NRC_MODE_${targetName} ${nrcMode} CACHE INTERNAL "")
        add_subdirectory(${targetPath})

    else()
        message(WARNING "${targetPath} doesn't exists.")

    endif()

endfunction()

#------------------------------------------------------------------------------

function(setTargetFilter targetName targetPath)

    get_filename_component(filter ${targetPath} PATH)

    if (filter)
        set_target_properties(${targetName} PROPERTIES FOLDER ${filter})
    endif()

endfunction()

#------------------------------------------------------------------------------

function(staticLib libPath dependencies nrcMode)

	# Library location
    set(libSourcePath ${CMAKE_CURRENT_SOURCE_DIR}/${libPath})
    get_filename_component(libDir ${libPath} PATH)
    get_filename_component(libName ${libPath} NAME)
	set(libBinaryPath ${CMAKE_LIB_PATH}/${NAPPGUI_COMPILER_TOOLSET}_${NAPPGUI_ARCH}/Debug/${libDir}/${NAPPGUI_LIB_PREFIX}${libName}${NAPPGUI_LIB_SUFFIX})
	set(${libPath}_DIRECTDEPENDS "${dependencies}" CACHE INTERNAL "")

	# Library exists as binary
    if (EXISTS ${libBinaryPath})
        message(STATUS "- ${libName}: Detected binary file")

    else()			
		# New Library (doesn't exists yet)
		if (NOT EXISTS ${libSourcePath})

			set(libPathName ${libSourcePath}/${libName})
			string(TOUPPER ${libName} libNameUpper)

			# New directory
			file(MAKE_DIRECTORY ${libPath})
			file(MAKE_DIRECTORY ${libPath}/res)

			# lib.hxx file
			file(WRITE ${libPathName}.hxx "/* ${libName} */\n\n")
			file(APPEND ${libPathName}.hxx "#ifndef __${libNameUpper}_HXX__\n")
			file(APPEND ${libPathName}.hxx "#define __${libNameUpper}_HXX__\n\n")

			foreach(dependency ${dependencies})
				file(APPEND ${libPathName}.hxx "#include \"${dependency}.hxx\"\n")
			endforeach()

			file(APPEND ${libPathName}.hxx "\n")
			file(APPEND ${libPathName}.hxx "/* TODO: Define data types here */\n\n")
			file(APPEND ${libPathName}.hxx "#endif\n")

			# lib.h file
			file(WRITE ${libPathName}.h "/* ${libName} */\n\n")
			file(APPEND ${libPathName}.h "#include \"${libName}.hxx\"\n\n")
			file(APPEND ${libPathName}.h "__EXTERN_C\n\n")
			file(APPEND ${libPathName}.h "void ${libName}_start(void);\n\n")
			file(APPEND ${libPathName}.h "void ${libName}_finish(void);\n\n")
			file(APPEND ${libPathName}.h "__END_C\n")

			# lib.c file
			file(WRITE ${libPathName}.c "/* ${libName} */\n\n")
			file(APPEND ${libPathName}.c "#include \"${libName}.h\"\n\n")
			file(APPEND ${libPathName}.c "/*---------------------------------------------------------------------------*/\n\n")
			file(APPEND ${libPathName}.c "void ${libName}_start(void)\n")
			file(APPEND ${libPathName}.c "{\n")
			file(APPEND ${libPathName}.c "    /*TODO: Implement library initialization code here */\n")
			file(APPEND ${libPathName}.c "}\n\n")
			file(APPEND ${libPathName}.c "/*---------------------------------------------------------------------------*/\n\n")
			file(APPEND ${libPathName}.c "void ${libName}_finish(void)\n")
			file(APPEND ${libPathName}.c "{\n")
			file(APPEND ${libPathName}.c "    /*TODO: Implement library ending code here */\n")
			file(APPEND ${libPathName}.c "}\n\n")

			message(STATUS "- ${libName}: Created new project")
		endif()

		# CMakeLists.txt create/update
		file(WRITE ${libSourcePath}/CMakeLists.txt "processStaticLib(${libName} \"${dependencies}\")")

		# Configure (from target dir)
		addTarget(${libName} ${libPath} ${nrcMode})

		# Filter (folder in IDE)
		setTargetFilter(${libName} ${libPath})

	endif()

endfunction()

#------------------------------------------------------------------------------

function(commandApp appPath dependencies nrcMode)

    set(appFullPath ${CMAKE_CURRENT_SOURCE_DIR}/${appPath})
    get_filename_component(appName ${appPath} NAME)

    if (NOT EXISTS ${appFullPath})
        set(resPath ${appFullPath}/res)
        file(MAKE_DIRECTORY ${appFullPath})
        file(MAKE_DIRECTORY ${resPath})

        # main.c
        string(TOLOWER ${appName} appNameLower)
        file(COPY ${CMAKE_PRJ_PATH}/templates/cmdmain.c DESTINATION ${appFullPath})
        file(RENAME ${appFullPath}/cmdmain.c ${appFullPath}/${appNameLower}.c)

        message(STATUS "- ${appName}: Created new project")
    endif()

    # CMakeLists.txt create/update
    file(WRITE ${appFullPath}/CMakeLists.txt "processCommandApp(${appName} \"${dependencies}\")")
       
    # Configure (from target dir)
	addTarget(${appName} ${appPath} ${nrcMode})

    # Filter (folder in IDE)
    setTargetFilter(${appName} ${appPath})

endfunction()

#------------------------------------------------------------------------------

function(desktopApp appName appPath dependencies nrcMode)

    set(appFullPath ${CMAKE_CURRENT_SOURCE_DIR}/${appPath})

    if (NOT EXISTS ${appFullPath})
        set(resPath ${appFullPath}/res)
        file(MAKE_DIRECTORY ${appFullPath})
        file(MAKE_DIRECTORY ${resPath})

        # logo
        file(COPY ${CMAKE_PRJ_PATH}/templates/logo.icns DESTINATION ${resPath})
        file(COPY ${CMAKE_PRJ_PATH}/templates/logo256.ico DESTINATION ${resPath})
        file(COPY ${CMAKE_PRJ_PATH}/templates/logo48.ico DESTINATION ${resPath})
        file(COPY ${CMAKE_PRJ_PATH}/templates/banner.bmp DESTINATION ${resPath})

        # license
        file(COPY ${CMAKE_PRJ_PATH}/templates/license.txt DESTINATION ${resPath})

        # pack.txt
        file(WRITE ${resPath}/pack.txt "VENDOR=NAppGUI\n")
        file(APPEND ${resPath}/pack.txt "VERSION=1.0\n")
        file(APPEND ${resPath}/pack.txt "DESC=Write here the application description\n")

        # main.c
        file(COPY ${CMAKE_PRJ_PATH}/templates/main.c DESTINATION ${appFullPath})
        string(TOLOWER ${appName} appNameLower)
        file(RENAME ${appFullPath}/main.c ${appFullPath}/${appNameLower}.c)

        message(STATUS "- ${appName}: Created new project")
    endif()

    # CMakeLists.txt create/update
    file(WRITE ${appFullPath}/CMakeLists.txt "processDesktopApp(${appName} \"${dependencies}\")")
       
    # Configure (from target dir)
	addTarget(${appName} ${appPath} ${nrcMode})

    # Filter (folder in IDE)
    setTargetFilter(${appName} ${appPath})

endfunction()

